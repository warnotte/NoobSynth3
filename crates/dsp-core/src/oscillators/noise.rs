//! Noise generator module.
//!
//! Generates white, pink, and brown (red) noise using efficient algorithms.

use crate::common::{sample_at, Sample};

/// Noise generator with white, pink, and brown noise colors.
///
/// # Noise Types
///
/// - **White noise** (type=0): Equal energy at all frequencies. Generated using
///   a linear congruential generator (LCG) for efficiency.
///
/// - **Pink noise** (type=1): -3dB/octave slope. Energy decreases with frequency.
///   Uses the Voss-McCartney algorithm with 7 octave bands.
///
/// - **Brown noise** (type=2): -6dB/octave slope (Brownian motion).
///   Generated by integrating white noise with clamping.
///
/// # Example
///
/// ```ignore
/// use dsp_core::oscillators::{Noise, NoiseParams};
///
/// let mut noise = Noise::new();
/// let mut output = [0.0f32; 128];
///
/// let level = [0.5; 128];
/// let noise_type = [1.0; 128]; // pink noise
///
/// noise.process_block(&mut output, NoiseParams {
///     level: &level,
///     noise_type: &noise_type,
/// });
/// ```
pub struct Noise {
    seed: u32,
    pink: [f32; 7],
    brown: f32,
}

/// Parameters for noise generation.
pub struct NoiseParams<'a> {
    /// Output level (0.0 to 1.0)
    pub level: &'a [Sample],
    /// Noise type: 0=white, 1=pink, 2=brown
    pub noise_type: &'a [Sample],
}

impl Noise {
    /// Create a new noise generator.
    pub fn new() -> Self {
        Self {
            seed: 0x1234_5678,
            pink: [0.0; 7],
            brown: 0.0,
        }
    }

    /// Generate next white noise sample using LCG.
    fn next_white(&mut self) -> f32 {
        self.seed = self
            .seed
            .wrapping_mul(1664525)
            .wrapping_add(1013904223);
        let raw = (self.seed >> 9) as f32 / 8_388_608.0;
        raw * 2.0 - 1.0
    }

    /// Generate next pink noise sample using Voss-McCartney algorithm.
    fn next_pink(&mut self) -> f32 {
        let white = self.next_white();
        self.pink[0] = 0.99886 * self.pink[0] + white * 0.0555179;
        self.pink[1] = 0.99332 * self.pink[1] + white * 0.0750759;
        self.pink[2] = 0.96900 * self.pink[2] + white * 0.1538520;
        self.pink[3] = 0.86650 * self.pink[3] + white * 0.3104856;
        self.pink[4] = 0.55000 * self.pink[4] + white * 0.5329522;
        self.pink[5] = -0.7616 * self.pink[5] - white * 0.0168980;
        let pink = self.pink[0]
            + self.pink[1]
            + self.pink[2]
            + self.pink[3]
            + self.pink[4]
            + self.pink[5]
            + self.pink[6]
            + white * 0.5362;
        self.pink[6] = white * 0.115926;
        pink * 0.11
    }

    /// Generate next brown noise sample by integrating white noise.
    fn next_brown(&mut self) -> f32 {
        let white = self.next_white();
        self.brown = (self.brown + white * 0.02).clamp(-1.0, 1.0);
        self.brown * 3.5
    }

    /// Process a block of noise.
    ///
    /// # Arguments
    ///
    /// * `output` - Output buffer to fill
    /// * `params` - Processing parameters
    pub fn process_block(&mut self, output: &mut [Sample], params: NoiseParams<'_>) {
        if output.is_empty() {
            return;
        }
        for i in 0..output.len() {
            let level = sample_at(params.level, i, 0.4).clamp(0.0, 1.0);
            let color = sample_at(params.noise_type, i, 0.0);
            let noise = if color < 0.5 {
                self.next_white()
            } else if color < 1.5 {
                self.next_pink()
            } else {
                self.next_brown()
            };
            output[i] = noise * level;
        }
    }
}

impl Default for Noise {
    fn default() -> Self {
        Self::new()
    }
}
