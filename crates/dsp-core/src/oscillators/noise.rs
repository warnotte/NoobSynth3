//! Noise generator module.
//!
//! Generates white, pink, brown, blue, and violet noise with stereo support.

use crate::common::{sample_at, Sample};

/// Noise generator with multiple noise colors and stereo output.
///
/// # Noise Types
///
/// - **White noise** (type=0): Equal energy at all frequencies. Generated using
///   a linear congruential generator (LCG) for efficiency.
///
/// - **Pink noise** (type=1): -3dB/octave slope. Energy decreases with frequency.
///   Uses the Voss-McCartney algorithm with 7 octave bands.
///
/// - **Brown noise** (type=2): -6dB/octave slope (Brownian motion).
///   Generated by integrating white noise with clamping.
///
/// - **Blue noise** (type=3): +3dB/octave slope. Energy increases with frequency.
///   Generated by differentiating pink noise.
///
/// - **Violet noise** (type=4): +6dB/octave slope. Energy increases rapidly with frequency.
///   Generated by differentiating white noise.
///
/// # Stereo
///
/// The stereo parameter controls the width of the stereo field:
/// - 0.0 = mono (identical L/R)
/// - 1.0 = full stereo (independent L/R noise)
pub struct Noise {
    // Left channel state
    seed_l: u32,
    pink_l: [f32; 7],
    brown_l: f32,
    prev_white_l: f32,
    prev_pink_l: f32,
    // Right channel state
    seed_r: u32,
    pink_r: [f32; 7],
    brown_r: f32,
    prev_white_r: f32,
    prev_pink_r: f32,
}

/// Parameters for noise generation.
pub struct NoiseParams<'a> {
    /// Output level (0.0 to 1.0)
    pub level: &'a [Sample],
    /// Noise type: 0=white, 1=pink, 2=brown, 3=blue, 4=violet
    pub noise_type: &'a [Sample],
    /// Stereo width (0.0 = mono, 1.0 = full stereo)
    pub stereo: &'a [Sample],
    /// Pan position (-1.0 = left, 0.0 = center, 1.0 = right)
    pub pan: &'a [Sample],
}

impl Noise {
    /// Create a new noise generator.
    pub fn new() -> Self {
        Self {
            seed_l: 0x1234_5678,
            pink_l: [0.0; 7],
            brown_l: 0.0,
            prev_white_l: 0.0,
            prev_pink_l: 0.0,
            seed_r: 0x8765_4321, // Different seed for right channel
            pink_r: [0.0; 7],
            brown_r: 0.0,
            prev_white_r: 0.0,
            prev_pink_r: 0.0,
        }
    }

    /// Generate next white noise sample using LCG (left channel).
    fn next_white_l(&mut self) -> f32 {
        self.seed_l = self
            .seed_l
            .wrapping_mul(1664525)
            .wrapping_add(1013904223);
        let raw = (self.seed_l >> 9) as f32 / 8_388_608.0;
        raw * 2.0 - 1.0
    }

    /// Generate next white noise sample using LCG (right channel).
    fn next_white_r(&mut self) -> f32 {
        self.seed_r = self
            .seed_r
            .wrapping_mul(1664525)
            .wrapping_add(1013904223);
        let raw = (self.seed_r >> 9) as f32 / 8_388_608.0;
        raw * 2.0 - 1.0
    }

    /// Generate next pink noise sample (left channel).
    fn next_pink_l(&mut self) -> f32 {
        let white = self.next_white_l();
        self.pink_l[0] = 0.99886 * self.pink_l[0] + white * 0.0555179;
        self.pink_l[1] = 0.99332 * self.pink_l[1] + white * 0.0750759;
        self.pink_l[2] = 0.96900 * self.pink_l[2] + white * 0.1538520;
        self.pink_l[3] = 0.86650 * self.pink_l[3] + white * 0.3104856;
        self.pink_l[4] = 0.55000 * self.pink_l[4] + white * 0.5329522;
        self.pink_l[5] = -0.7616 * self.pink_l[5] - white * 0.0168980;
        let pink = self.pink_l[0]
            + self.pink_l[1]
            + self.pink_l[2]
            + self.pink_l[3]
            + self.pink_l[4]
            + self.pink_l[5]
            + self.pink_l[6]
            + white * 0.5362;
        self.pink_l[6] = white * 0.115926;
        pink * 0.11
    }

    /// Generate next pink noise sample (right channel).
    fn next_pink_r(&mut self) -> f32 {
        let white = self.next_white_r();
        self.pink_r[0] = 0.99886 * self.pink_r[0] + white * 0.0555179;
        self.pink_r[1] = 0.99332 * self.pink_r[1] + white * 0.0750759;
        self.pink_r[2] = 0.96900 * self.pink_r[2] + white * 0.1538520;
        self.pink_r[3] = 0.86650 * self.pink_r[3] + white * 0.3104856;
        self.pink_r[4] = 0.55000 * self.pink_r[4] + white * 0.5329522;
        self.pink_r[5] = -0.7616 * self.pink_r[5] - white * 0.0168980;
        let pink = self.pink_r[0]
            + self.pink_r[1]
            + self.pink_r[2]
            + self.pink_r[3]
            + self.pink_r[4]
            + self.pink_r[5]
            + self.pink_r[6]
            + white * 0.5362;
        self.pink_r[6] = white * 0.115926;
        pink * 0.11
    }

    /// Generate next brown noise sample (left channel).
    fn next_brown_l(&mut self) -> f32 {
        let white = self.next_white_l();
        self.brown_l = (self.brown_l + white * 0.02).clamp(-1.0, 1.0);
        self.brown_l * 3.5
    }

    /// Generate next brown noise sample (right channel).
    fn next_brown_r(&mut self) -> f32 {
        let white = self.next_white_r();
        self.brown_r = (self.brown_r + white * 0.02).clamp(-1.0, 1.0);
        self.brown_r * 3.5
    }

    /// Generate next blue noise sample (left channel) - differentiated pink.
    fn next_blue_l(&mut self) -> f32 {
        let pink = self.next_pink_l();
        let blue = pink - self.prev_pink_l;
        self.prev_pink_l = pink;
        blue * 8.0 // Normalize
    }

    /// Generate next blue noise sample (right channel).
    fn next_blue_r(&mut self) -> f32 {
        let pink = self.next_pink_r();
        let blue = pink - self.prev_pink_r;
        self.prev_pink_r = pink;
        blue * 8.0
    }

    /// Generate next violet noise sample (left channel) - differentiated white.
    fn next_violet_l(&mut self) -> f32 {
        let white = self.next_white_l();
        let violet = white - self.prev_white_l;
        self.prev_white_l = white;
        violet * 0.5 // Normalize
    }

    /// Generate next violet noise sample (right channel).
    fn next_violet_r(&mut self) -> f32 {
        let white = self.next_white_r();
        let violet = white - self.prev_white_r;
        self.prev_white_r = white;
        violet * 0.5
    }

    /// Generate a sample for the given color (left channel).
    fn sample_l(&mut self, color: f32) -> f32 {
        if color < 0.5 {
            self.next_white_l()
        } else if color < 1.5 {
            self.next_pink_l()
        } else if color < 2.5 {
            self.next_brown_l()
        } else if color < 3.5 {
            self.next_blue_l()
        } else {
            self.next_violet_l()
        }
    }

    /// Generate a sample for the given color (right channel).
    fn sample_r(&mut self, color: f32) -> f32 {
        if color < 0.5 {
            self.next_white_r()
        } else if color < 1.5 {
            self.next_pink_r()
        } else if color < 2.5 {
            self.next_brown_r()
        } else if color < 3.5 {
            self.next_blue_r()
        } else {
            self.next_violet_r()
        }
    }

    /// Process a block of noise (mono output, backwards compatible).
    ///
    /// # Arguments
    ///
    /// * `output` - Output buffer to fill
    /// * `params` - Processing parameters
    pub fn process_block(&mut self, output: &mut [Sample], params: NoiseParams<'_>) {
        if output.is_empty() {
            return;
        }
        for i in 0..output.len() {
            let level = sample_at(params.level, i, 0.4).clamp(0.0, 1.0);
            let color = sample_at(params.noise_type, i, 0.0);
            let noise = self.sample_l(color);
            output[i] = noise * level;
        }
    }

    /// Process a block of stereo noise.
    ///
    /// # Arguments
    ///
    /// * `output_l` - Left channel output buffer
    /// * `output_r` - Right channel output buffer
    /// * `params` - Processing parameters
    pub fn process_block_stereo(
        &mut self,
        output_l: &mut [Sample],
        output_r: &mut [Sample],
        params: NoiseParams<'_>,
    ) {
        use std::f32::consts::FRAC_PI_4;

        if output_l.is_empty() {
            return;
        }
        for i in 0..output_l.len() {
            let level = sample_at(params.level, i, 0.4).clamp(0.0, 1.0);
            let color = sample_at(params.noise_type, i, 0.0);
            let stereo = sample_at(params.stereo, i, 0.0).clamp(0.0, 1.0);
            let pan = sample_at(params.pan, i, 0.0).clamp(-1.0, 1.0);

            let noise_l = self.sample_l(color);
            let noise_r = self.sample_r(color);

            // Blend between mono (L=R) and full stereo based on stereo param
            let mono = (noise_l + noise_r) * 0.5;
            let out_l = mono * (1.0 - stereo) + noise_l * stereo;
            let out_r = mono * (1.0 - stereo) + noise_r * stereo;

            // Apply equal-power panning
            // pan -1 = left only, pan 0 = center, pan +1 = right only
            let angle = (pan + 1.0) * FRAC_PI_4; // 0 to PI/2
            let pan_l = angle.cos();
            let pan_r = angle.sin();

            output_l[i] = out_l * level * pan_l;
            output_r[i] = out_r * level * pan_r;
        }
    }
}

impl Default for Noise {
    fn default() -> Self {
        Self::new()
    }
}
